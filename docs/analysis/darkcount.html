<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pylars.analysis.darkcount API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pylars.analysis.darkcount</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
from datetime import datetime

import numpy as np
import pandas as pd
import pylars
import pylars.plotting.plotanalysis
import pylars.utils.input
import pylars.utils.output
import scipy.interpolate as itp
from pylars.analysis.breakdown import compute_BV
from scipy.optimize import curve_fit
from tqdm import tqdm

from .common import Gaussean, func_linear


class DCR_dataset():
    &#34;&#34;&#34;Object class to hold dark count related instances and
    methods. Collects all the data and properties of a single MMPC,
    meaning the pair (module, channel) for all the available voltages at
    a certain temperature.
    &#34;&#34;&#34;

    __version__ = &#39;0.0.1&#39;

    def __init__(self, run: pylars.utils.input.run, temperature: float,
                 module: int, channel: str,
                 processor: pylars.processing.rawprocessor.run_processor):

        self.run = run
        self.temp = temperature
        self.module = module
        self.channel = channel
        self.process = processor
        self.voltages = self.get_voltages_available()
        self.plots_flag = False

    def set_plots_flag(self, flag: bool) -&gt; None:
        &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
        Assumes a ./figures/ directory exists.

        Args:
            flag (bool): True for plotting stuff, False for not making nice
        pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
        wall and it looks nice.
        &#34;&#34;&#34;
        self.plots_flag = flag

    def define_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                          ADC_impedance: int = 50, ADC_res: float = 2**14,
                          q_e: float = 1.602176634e-19) -&gt; None:
        &#34;&#34;&#34;Define the ADC related quantities for the dataset.

        Args:
            F_amp (float): signal amplification from the sensor (pre-amp *
        external amplification on rack)
            ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
            ADC_impedance (int, optional): Impedance of the ADC and cables
        [ohm]. Defaults to 50.
            ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
        Defaults to 2**14.
            q_e (float, optional): Element charge of the electron [C].
        Defaults to 1.602176634e-19.
        &#34;&#34;&#34;
        ADC_config = {&#39;ADC_range&#39;: ADC_range,
                      &#39;ADC_impedance&#39;: ADC_impedance,
                      &#39;F_amp&#39;: F_amp,
                      &#39;ADC_res&#39;: ADC_res,
                      &#39;q_e&#39;: q_e}

        self.ADC_config = ADC_config

    def define_SiPM_config(self, livetime: float,
                           sensor_area: float = 12 * 12,
                           ) -&gt; None:
        &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

        Args:
            livetime (float): livetime of the measurement for DCR porpuses.
            sensor_area (float, optional): Area of the photosensor (mm**2).
        Defaults to 12*12.
        &#34;&#34;&#34;
        SiPM_config = {&#39;livetime&#39;: livetime,
                       &#39;sensor_area&#39;: sensor_area,
                       }

        self.SiPM_config = SiPM_config

    def get_voltages_available(self) -&gt; np.array:
        &#34;&#34;&#34;Checks the loaded run for which voltages are available for the
        defined temperature.

        Returns:
            np.array: array of the available voltages
        &#34;&#34;&#34;

        voltages = []
        for _dataset in self.run.datasets:
            if (_dataset.temp == self.temp) and (_dataset.kind == &#39;DCR&#39;):
                voltages.append(_dataset.vbias)
        voltages = np.unique(voltages)

        return voltages

    def load_processed_data(self, force_processing: bool = False) -&gt; dict:
        &#34;&#34;&#34;For all the voltages of a DCR_dataset (smae temperature) looks
        for already processed files to load. If force_processing=True and
        no saved file is found, processes the dataset with standard
        options (sigma = 5, N_baseline = 50).

        Args:
            force_processing (bool, optional): Flag to force processing
        of raw data in case the processed dataset is not found. Defaults
        to False.

        Returns:
            dict: _description_
        &#34;&#34;&#34;
        self.data = {}
        for _voltage in self.voltages:
            processed_data = pylars.utils.output.processed_dataset(
                run=self.run,
                kind=&#39;DCR&#39;,
                vbias=_voltage,
                temp=self.temp,
                path_processed=(&#39;/disk/gfs_atp/xenoscope/SiPMs/char_campaign/&#39;
                                &#39;processed_data/&#39;),
                process_hash=self.process.hash)
            processed_data.load_data(force=force_processing)

            _df = processed_data.data
            mask = ((_df[&#39;module&#39;] == self.module) &amp;
                    (_df[&#39;channel&#39;] == self.channel))

            self.data[_voltage] = copy.deepcopy(_df[mask])

    @classmethod
    def get_1pe_value_fit(cls,
                          df: pd.DataFrame,
                          length_cut: int = 5,
                          plot: bool or str = False) -&gt; tuple:
        &#34;&#34;&#34;Try to fit the SPE peak in the area histogram and return the
        Gaussian paramenters.

        Args:
            df (pd.DataFrame): _description_
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            plot (boolorstr, optional): _description_. Defaults to False.

        Returns:
            tuple: _description_
        &#34;&#34;&#34;

        (area_hist_x, DCR_values, DCR_der_x_points,
         DCR_der_y_points, min_area_x) = cls.get_1pe_rough(df, length_cut)

        if plot != False:
            pylars.plotting.plotanalysis.plot_DCR_curve(
                plot, area_hist_x, DCR_values, DCR_der_x_points,
                DCR_der_y_points, min_area_x)

        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=np.linspace(0.5 * min_area_x, 1.5 * min_area_x, 300))
        area_hist_x = area_hist[1]
        area_hist_x = (
            area_hist_x + (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]

        (A, mu, sigma), cov = curve_fit(Gaussean, area_hist_x, area_hist_y,
                                        p0=(2000, min_area_x, 0.05 * min_area_x))

        if plot != False:
            pylars.plotting.plotanalysis.plot_SPE_fit(
                df, length_cut, plot, area_hist_x, min_area_x, A, mu, sigma)

        return (A, mu, sigma), cov

    @classmethod
    def get_1pe_rough(cls, df: pd.DataFrame,
                      length_cut: int,
                      bins: int or list = 200) -&gt; tuple:
        &#34;&#34;&#34;From an event df (1 channel), find the rough position of the
        SPE from the DCR vs threshold curve and its derivative

        Args:
            df (_type_): _description_
            length_cut (_type_): _description_
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            tuple: _description_
        &#34;&#34;&#34;

        (area_hist_x, DCR_values) = cls.get_DCR_above_threshold_values(
            df, length_cut, bins)
        grad = np.gradient(DCR_values)
        grad_spline = itp.UnivariateSpline(area_hist_x, grad)
        # , s = len(area_hist_x)*3)
        _x = np.linspace(area_hist_x[0], area_hist_x[-1], 500)
        _y = grad_spline(_x)
        min_idx = np.where(_y == min(_y))
        min_area_x = _x[min_idx][0]
        return area_hist_x, DCR_values, _x, _y, min_area_x

    @classmethod
    def get_DCR_above_threshold_values(cls, df: pd.DataFrame,
                                       length_cut: int = 5,
                                       bins: int or list = 200) -&gt; tuple:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns the pair [area thersholds, DCR values]

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            tuple: pair of np.arrays (area thersholds, DCR values)
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]

        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))

        return (area_hist_x, DCR_values)

    @classmethod
    def get_DCR_above_threshold_spline(cls, df: pd.DataFrame,
                                       length_cut: int = 5,
                                       bins: int or list = 200,
                                       **kwargs) -&gt; itp.UnivariateSpline:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns a spline object of the curve.

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            itp.UnivariateSpline: spline object of the DCR vs area
        threshold curve.
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]
        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
        DCR_func = itp.UnivariateSpline(area_hist_x, DCR_values, **kwargs)

        return DCR_func

    @classmethod
    def get_DCR_above_threshold_interp1d(cls, df: pd.DataFrame,
                                         length_cut: int = 5,
                                         bins: int or list = 200
                                         ) -&gt; itp.interp1d:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns a 1D interpolation object of the curve.

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            itp.interp1d: 1D interpolation object of the DCR vs area
        threshold curve.
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]
        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
        DCR_func = itp.interp1d(area_hist_x, DCR_values)

        return DCR_func

    @staticmethod
    def get_DCR(df: pd.DataFrame,
                length_cut_min: int,
                length_cut_max: int,
                pe_area: float,
                sensor_area: float,
                t: float) -&gt; tuple:
        &#34;&#34;&#34;Compute the dark count rate (DCR) and crosstalk probability
        (CTP) of a dataset.

        Args:
            df (pd.DataFrame): DataFrame of the dataset (single ch)
            length_cut_min (int): low length cut to apply
            length_cut_max (int): high length cut to apply
            pe_area (float): SPE area
            sensor_area (float): effective are of the sensor
            t (float): livetime of the dataset

        Returns:
            tuple: DCR value, error of DCR value, CTP value, error of
        CTP value
        &#34;&#34;&#34;
        pe_0_5 = pe_area * 0.5
        pe_1_5 = pe_area * 1.5

        DC_0_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                        (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                        (df[&#39;area&#39;] &gt; pe_0_5)])
        DC_1_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                        (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                        (df[&#39;area&#39;] &gt; pe_1_5)])

        DC_0_5_error = np.sqrt(DC_0_5)
        DC_1_5_error = np.sqrt(DC_1_5)

        DCR = DC_0_5 / sensor_area / t
        DCR_error = DC_0_5_error / sensor_area / t

        CTP = DC_1_5 / DC_0_5
        CTP_error = np.sqrt((DC_0_5_error / DC_1_5)**2 +
                            (DC_0_5 * DC_1_5_error / (DC_1_5)**2)**2)

        return DCR, DCR_error, CTP, CTP_error

    @staticmethod
    def print_DCR_CTP(DCR: float, DCR_error: float,
                      CTP: float, CTP_error: float) -&gt; None:
        &#34;&#34;&#34;Print the dark count rate (DCR) and crosstalk probability
        (CTP) values in a nice formatted and welcoming message.

        Args:
            DCR (float): DCR value
            DCR_error (float): Error on the DCR value
            CTP (float): CTP value
            CTP_error (float): Error on the CTP value
        &#34;&#34;&#34;

        print(f&#39;Your lovely DCR is: ({DCR:.2f} +- {DCR_error:.2f}) Hz/mm^2&#39;)
        print(f&#39;Your lovely CTP is: ({CTP*100:.2f} +- {CTP_error*100:.2f})%&#39;)

    def get_gain(self, spe_area: float) -&gt; float:
        &#34;&#34;&#34;Compute the gain given the value of the SPE area

        Args:
            spe_area (float): Area of the SPE peak in integrated ADC
        counts [ADC count * ns].

        Raises:
            ValueError: self.ADC_config not defined for the current dataset.
        Run dataset.define_ADC_config(...)

        Returns:
            float: the calculated gain.
        &#34;&#34;&#34;

        if not isinstance(self.ADC_config, dict):
            raise ValueError(&#39;Define ADC_config first.&#39;)

        ADC_range = self.ADC_config[&#39;ADC_range&#39;]
        ADC_impedance = self.ADC_config[&#39;ADC_impedance&#39;]
        F_amp = self.ADC_config[&#39;F_amp&#39;]
        ADC_res = self.ADC_config[&#39;ADC_res&#39;]
        q_e = self.ADC_config[&#39;q_e&#39;]

        gain = (ADC_range * spe_area * 1e-9 / ADC_impedance / F_amp /
                ADC_res / q_e)

        return gain

    def compute_properties_of_dataset(self,
                                      length_cut_min: int = 4,
                                      length_cut_max: int = 20) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Calculate the gain, DCR, CTP and BV for the dataset in a single
        line!

        Args:
            temp (float): temperature to consider in the dataset.
            module (int): module to load.
            channel (str): channel to load.
            length_cut_min (int): lower bound accepted for the length of
        peaks. Defaults to 4.
            length_cut_max (int): upper bound accepted for the length of
        peaks. Defaults to 20.

        Returns:
            pd.DataFrame: dataframe with all the computed properties with
        the columns [&#39;V&#39;,&#39;T&#39;,&#39;path&#39;,&#39;module&#39;,&#39;channel&#39;,&#39;Gain&#39;,&#39;DCR&#39;,&#39;CTP&#39;,
        &#39;DCR_error&#39;,&#39;CTP_error&#39;,&#39;BV&#39;,&#39;OV&#39;]
        &#34;&#34;&#34;

        assert isinstance(self.data, dict), (&#39;Woops, no data found! Load&#39;
                                             &#39; data into the dataset first&#39;)

        voltage_list = self.voltages

        _results_dataset = pd.DataFrame(columns=[&#39;T&#39;, &#39;V&#39;, &#39;pe_area&#39;, &#39;Gain&#39;,
                                                 &#39;res&#39;, &#39;DCR&#39;, &#39;DCR_error&#39;,
                                                 &#39;CTP&#39;, &#39;CTP_error&#39;])

        for _volt in voltage_list:
            # select voltage
            df = self.data[_volt]
            if self.plots_flag == True:
                plot_name_1pe_fit = (f&#39;{self.temp}K_{_volt}V_mod{self.module}_&#39;
                                     f&#39;ch{self.channel}&#39;)
            else:
                plot_name_1pe_fit = False

            # Get SPE value from Gaussian fit
            (A, mu, sigma), cov = self.get_1pe_value_fit(
                df, plot=plot_name_1pe_fit)

            # Calculate DCR and CTP
            DCR, DCR_error, CTP, CTP_error = self.get_DCR(
                df=df,
                length_cut_min=length_cut_min,
                length_cut_max=length_cut_max,
                pe_area=mu,
                sensor_area=self.SiPM_config[&#39;sensor_area&#39;],
                t=self.SiPM_config[&#39;livetime&#39;])

            # Calculate gain
            gain = self.get_gain(mu)

            # Merge into rolling dataframe (I know it&#39;s slow... make a PR, pls)
            _results_dataset = pd.concat((_results_dataset,
                                          pd.DataFrame({&#39;T&#39;: [self.temp],
                                                        &#39;V&#39;: [_volt],
                                                        &#39;pe_area&#39;: [mu],
                                                        &#39;Gain&#39;: [gain],
                                                        &#39;res&#39;: [mu / sigma],
                                                        &#39;DCR&#39;: [DCR],
                                                        &#39;DCR_error&#39;: [DCR_error],
                                                        &#39;CTP&#39;: [CTP],
                                                        &#39;CTP_error&#39;: [CTP_error]})
                                          ), ignore_index=True)

        # Compute BV from gain(V) curve and update df
        if self.plots_flag == True:
            plot_BV = f&#39;BV_mod{self.module}_ch{self.channel}&#39;
        else:
            plot_BV = False
        _results_dataset = compute_BV(_results_dataset, plot_BV)

        return _results_dataset


class DCR_run():
    &#34;&#34;&#34;Collection of all the DCR_datasets results for a run, ie, for all
    the channels and modules, for every available temperatures and voltages.

    The results of every dataset (channel, V, T) is saved on the instance
    DCR_run.results_df .
    &#34;&#34;&#34;

    __version__ = &#39;0.0.1&#39;

    def __init__(self, run: pylars.utils.input.run,
                 processor: pylars.processing.rawprocessor.run_processor):

        self.run = run
        self.process = processor
        self.datasets = self.process.datasets_df
        self.temperatures = self.get_run_temperatures()
        self.plots_flag = False
        self.analysis_path = (f&#39;{self.run.main_data_path[:-9]}analysis_data&#39;
                              f&#39;/run{self.run.run_number}/&#39;)

    def set_plots_flag(self, flag: bool) -&gt; None:
        &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
        Assumes a ./figures/ directory exists.

        Args:
            flag (bool): True for plotting stuff, False for not making nice
        pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
        wall and it looks nice.
        &#34;&#34;&#34;
        self.plots_flag = flag

    def get_run_temperatures(self) -&gt; np.array:
        &#34;&#34;&#34;Get all the temperatures available in the DCR run.

        Returns:
            np.array: array with all the available temperatures.
        &#34;&#34;&#34;
        temp_list = np.unique(self.datasets[&#39;temp&#39;])

        return temp_list

    def initialize_results_df(self) -&gt; None:
        &#34;&#34;&#34;Initialize a clean results_df instance in the object.
        &#34;&#34;&#34;

        results_df = pd.DataFrame(columns=[&#39;V&#39;, &#39;T&#39;, &#39;module&#39;, &#39;channel&#39;,
                                           &#39;Gain&#39;, &#39;DCR&#39;, &#39;CTP&#39;, &#39;DCR_error&#39;,
                                           &#39;CTP_error&#39;, &#39;BV&#39;, &#39;OV&#39;]
                                  )
        self.results_df = results_df

    def define_run_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                              ADC_impedance: int = 50, ADC_res: float = 2**14,
                              q_e: float = 1.602176634e-19) -&gt; None:
        &#34;&#34;&#34;Define the ADC related quantities for the dataset.

        Args:
            F_amp (float): signal amplification from the sensor (pre-amp *
        external amplification on rack)
            ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
            ADC_impedance (int, optional): Impedance of the ADC and cables
        [ohm]. Defaults to 50.
            ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
        Defaults to 2**14.
            q_e (float, optional): Element charge of the electron [C].
        Defaults to 1.602176634e-19.
        &#34;&#34;&#34;
        ADC_config = {&#39;ADC_range&#39;: ADC_range,
                      &#39;ADC_impedance&#39;: ADC_impedance,
                      &#39;F_amp&#39;: F_amp,
                      &#39;ADC_res&#39;: ADC_res,
                      &#39;q_e&#39;: q_e}

        self.ADC_config = ADC_config

    def define_run_SiPM_config(self, livetime: float,
                               sensor_area: float = 12 * 12,
                               ) -&gt; None:
        &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

        Args:
            livetime (float): livetime of the measurement for DCR porpuses.
            sensor_area (float, optional): Area of the photosensor (mm**2).
        Defaults to 12*12.
        &#34;&#34;&#34;
        SiPM_config = {&#39;livetime&#39;: livetime,
                       &#39;sensor_area&#39;: sensor_area,
                       }
        self.SiPM_config = SiPM_config

    def load_dataset(self, temp: float,
                     module: int,
                     channel: str) -&gt; DCR_dataset:
        &#34;&#34;&#34;Create a DCR_dataset object for a (T, mod, ch) configuration and
        load the corresponding data into it.
        ! This assumes processed data is availabel for all the raw files of
        the DCR run datasets !

        Args:
            temp (float): temperature to consider
            module (int): module to load
            channel (str): channel in the module to select

        Returns:
            DCR_dataset: _description_
        &#34;&#34;&#34;
        particular_DCR_dataset = DCR_dataset(run=self.run,
                                             temperature=temp,
                                             module=module,
                                             channel=channel,
                                             processor=self.process,
                                             )

        particular_DCR_dataset.load_processed_data()

        return particular_DCR_dataset

    def compute_properties_of_ds(self, temp: float,
                                 module: int,
                                 channel: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Loads and computes the properties of a single dataset (temp,
        module, channel) by creating a DCR_dataset object and calling its
        methods.

        Args:
            temp (float): temperature
            module (int): module
            channel (str): channel

        Returns:
            pd.DataFrame: dataframe
        &#34;&#34;&#34;

        assert isinstance(self.SiPM_config, dict), &#39;No SiPM_config found!&#39;
        assert isinstance(self.ADC_config, dict), &#39;No ADC_config found!&#39;

        ds = self.load_dataset(temp, module, channel)
        ds.set_plots_flag(self.plots_flag)
        ds.ADC_config = self.ADC_config
        ds.SiPM_config = self.SiPM_config

        ds_results = ds.compute_properties_of_dataset()

        # Add module and channel columns
        module_Series = pd.Series([module] * len(ds_results), name=&#39;module&#39;)
        channel_Series = pd.Series([channel] * len(ds_results), name=&#39;channel&#39;)
        ds_results = pd.concat([ds_results, module_Series, channel_Series],
                               axis=1)
        return ds_results

    def read_channel_map(self, path_to_map: str) -&gt; None:
        &#34;&#34;&#34;Define the active modules and channels for the run.
        UNDER CONSTRUCTION. I know it doesn&#39;t work that nicely but
        I need to have somthing that works for now, so...
        Define it with self.channel_map = dict(mod:[ch#,...],...)

        Args:
            path_to_map (str): path to csv file with the channel map
        &#34;&#34;&#34;
        if self.run.run_number == 7:
            channel_map = {0: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;],
                           1: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;], }
        else:
            channel_map = pd.read_csv(path_to_map)

        self.channel_map = channel_map

    def compute_properties_of_run(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Loads and computes the properties of ALL the datasets.

        Returns:
            pd.DataFrame: The results.
        &#34;&#34;&#34;
        self.initialize_results_df()

        for temperature in self.temperatures:
            for module in self.channel_map.keys():
                for channel in tqdm(self.channel_map[module],
                                    (f&#39;Computing properties for &#39;
                                     f&#39;T={temperature}; module &#39;
                                     f&#39;{module}: &#39;)):
                    _ds_results = self.compute_properties_of_ds(
                        temp=temperature,
                        module=module,
                        channel=channel)

                    self.results_df = pd.concat([self.results_df, _ds_results],
                                                ignore_index=True)

        datetime.now()

    def save_results(self, custom_name:str = str(int(
            datetime.timestamp(datetime.now())))) -&gt; None:
        f&#34;&#34;&#34;Save dataframe of results to a hdf5 file. Saved files go to 
        {self.analysis_path} .

        Args:
            name (str): name to give the file (without extension). Defaults to
        timestamp of 
        &#34;&#34;&#34;
        assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
            &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
        assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
            &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
            &#34;disk space&#34;)

        name = f&#39;DCR_results_{custom_name}&#39;
        self.results_df.to_hdf(self.analysis_path + name + &#39;.h5&#39;, &#39;df&#39;)
        print(&#39;Saved results to &#39;)
    
    def load_results(self, name:str) -&gt; None:
        f&#34;&#34;&#34;Load dataframe of results from a hdf5 file. Looks for files in 
        {self.analysis_path} .

        Args:
            name (str): name of the file to load (without extension)
        &#34;&#34;&#34;
        assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
            &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
        assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
            &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
            &#34;disk space&#34;)

        _df = pd.read_hdf(self.analysis_path + name + &#39;.h5&#39;)
        self.results_df = _df
        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pylars.analysis.darkcount.DCR_dataset"><code class="flex name class">
<span>class <span class="ident">DCR_dataset</span></span>
<span>(</span><span>run: <a title="pylars.utils.input.run" href="../utils/input.html#pylars.utils.input.run">run</a>, temperature: float, module: int, channel: str, processor: <a title="pylars.processing.rawprocessor.run_processor" href="../processing/rawprocessor.html#pylars.processing.rawprocessor.run_processor">run_processor</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Object class to hold dark count related instances and
methods. Collects all the data and properties of a single MMPC,
meaning the pair (module, channel) for all the available voltages at
a certain temperature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DCR_dataset():
    &#34;&#34;&#34;Object class to hold dark count related instances and
    methods. Collects all the data and properties of a single MMPC,
    meaning the pair (module, channel) for all the available voltages at
    a certain temperature.
    &#34;&#34;&#34;

    __version__ = &#39;0.0.1&#39;

    def __init__(self, run: pylars.utils.input.run, temperature: float,
                 module: int, channel: str,
                 processor: pylars.processing.rawprocessor.run_processor):

        self.run = run
        self.temp = temperature
        self.module = module
        self.channel = channel
        self.process = processor
        self.voltages = self.get_voltages_available()
        self.plots_flag = False

    def set_plots_flag(self, flag: bool) -&gt; None:
        &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
        Assumes a ./figures/ directory exists.

        Args:
            flag (bool): True for plotting stuff, False for not making nice
        pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
        wall and it looks nice.
        &#34;&#34;&#34;
        self.plots_flag = flag

    def define_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                          ADC_impedance: int = 50, ADC_res: float = 2**14,
                          q_e: float = 1.602176634e-19) -&gt; None:
        &#34;&#34;&#34;Define the ADC related quantities for the dataset.

        Args:
            F_amp (float): signal amplification from the sensor (pre-amp *
        external amplification on rack)
            ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
            ADC_impedance (int, optional): Impedance of the ADC and cables
        [ohm]. Defaults to 50.
            ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
        Defaults to 2**14.
            q_e (float, optional): Element charge of the electron [C].
        Defaults to 1.602176634e-19.
        &#34;&#34;&#34;
        ADC_config = {&#39;ADC_range&#39;: ADC_range,
                      &#39;ADC_impedance&#39;: ADC_impedance,
                      &#39;F_amp&#39;: F_amp,
                      &#39;ADC_res&#39;: ADC_res,
                      &#39;q_e&#39;: q_e}

        self.ADC_config = ADC_config

    def define_SiPM_config(self, livetime: float,
                           sensor_area: float = 12 * 12,
                           ) -&gt; None:
        &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

        Args:
            livetime (float): livetime of the measurement for DCR porpuses.
            sensor_area (float, optional): Area of the photosensor (mm**2).
        Defaults to 12*12.
        &#34;&#34;&#34;
        SiPM_config = {&#39;livetime&#39;: livetime,
                       &#39;sensor_area&#39;: sensor_area,
                       }

        self.SiPM_config = SiPM_config

    def get_voltages_available(self) -&gt; np.array:
        &#34;&#34;&#34;Checks the loaded run for which voltages are available for the
        defined temperature.

        Returns:
            np.array: array of the available voltages
        &#34;&#34;&#34;

        voltages = []
        for _dataset in self.run.datasets:
            if (_dataset.temp == self.temp) and (_dataset.kind == &#39;DCR&#39;):
                voltages.append(_dataset.vbias)
        voltages = np.unique(voltages)

        return voltages

    def load_processed_data(self, force_processing: bool = False) -&gt; dict:
        &#34;&#34;&#34;For all the voltages of a DCR_dataset (smae temperature) looks
        for already processed files to load. If force_processing=True and
        no saved file is found, processes the dataset with standard
        options (sigma = 5, N_baseline = 50).

        Args:
            force_processing (bool, optional): Flag to force processing
        of raw data in case the processed dataset is not found. Defaults
        to False.

        Returns:
            dict: _description_
        &#34;&#34;&#34;
        self.data = {}
        for _voltage in self.voltages:
            processed_data = pylars.utils.output.processed_dataset(
                run=self.run,
                kind=&#39;DCR&#39;,
                vbias=_voltage,
                temp=self.temp,
                path_processed=(&#39;/disk/gfs_atp/xenoscope/SiPMs/char_campaign/&#39;
                                &#39;processed_data/&#39;),
                process_hash=self.process.hash)
            processed_data.load_data(force=force_processing)

            _df = processed_data.data
            mask = ((_df[&#39;module&#39;] == self.module) &amp;
                    (_df[&#39;channel&#39;] == self.channel))

            self.data[_voltage] = copy.deepcopy(_df[mask])

    @classmethod
    def get_1pe_value_fit(cls,
                          df: pd.DataFrame,
                          length_cut: int = 5,
                          plot: bool or str = False) -&gt; tuple:
        &#34;&#34;&#34;Try to fit the SPE peak in the area histogram and return the
        Gaussian paramenters.

        Args:
            df (pd.DataFrame): _description_
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            plot (boolorstr, optional): _description_. Defaults to False.

        Returns:
            tuple: _description_
        &#34;&#34;&#34;

        (area_hist_x, DCR_values, DCR_der_x_points,
         DCR_der_y_points, min_area_x) = cls.get_1pe_rough(df, length_cut)

        if plot != False:
            pylars.plotting.plotanalysis.plot_DCR_curve(
                plot, area_hist_x, DCR_values, DCR_der_x_points,
                DCR_der_y_points, min_area_x)

        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=np.linspace(0.5 * min_area_x, 1.5 * min_area_x, 300))
        area_hist_x = area_hist[1]
        area_hist_x = (
            area_hist_x + (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]

        (A, mu, sigma), cov = curve_fit(Gaussean, area_hist_x, area_hist_y,
                                        p0=(2000, min_area_x, 0.05 * min_area_x))

        if plot != False:
            pylars.plotting.plotanalysis.plot_SPE_fit(
                df, length_cut, plot, area_hist_x, min_area_x, A, mu, sigma)

        return (A, mu, sigma), cov

    @classmethod
    def get_1pe_rough(cls, df: pd.DataFrame,
                      length_cut: int,
                      bins: int or list = 200) -&gt; tuple:
        &#34;&#34;&#34;From an event df (1 channel), find the rough position of the
        SPE from the DCR vs threshold curve and its derivative

        Args:
            df (_type_): _description_
            length_cut (_type_): _description_
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            tuple: _description_
        &#34;&#34;&#34;

        (area_hist_x, DCR_values) = cls.get_DCR_above_threshold_values(
            df, length_cut, bins)
        grad = np.gradient(DCR_values)
        grad_spline = itp.UnivariateSpline(area_hist_x, grad)
        # , s = len(area_hist_x)*3)
        _x = np.linspace(area_hist_x[0], area_hist_x[-1], 500)
        _y = grad_spline(_x)
        min_idx = np.where(_y == min(_y))
        min_area_x = _x[min_idx][0]
        return area_hist_x, DCR_values, _x, _y, min_area_x

    @classmethod
    def get_DCR_above_threshold_values(cls, df: pd.DataFrame,
                                       length_cut: int = 5,
                                       bins: int or list = 200) -&gt; tuple:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns the pair [area thersholds, DCR values]

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            tuple: pair of np.arrays (area thersholds, DCR values)
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]

        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))

        return (area_hist_x, DCR_values)

    @classmethod
    def get_DCR_above_threshold_spline(cls, df: pd.DataFrame,
                                       length_cut: int = 5,
                                       bins: int or list = 200,
                                       **kwargs) -&gt; itp.UnivariateSpline:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns a spline object of the curve.

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            itp.UnivariateSpline: spline object of the DCR vs area
        threshold curve.
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]
        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
        DCR_func = itp.UnivariateSpline(area_hist_x, DCR_values, **kwargs)

        return DCR_func

    @classmethod
    def get_DCR_above_threshold_interp1d(cls, df: pd.DataFrame,
                                         length_cut: int = 5,
                                         bins: int or list = 200
                                         ) -&gt; itp.interp1d:
        &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
        returns a 1D interpolation object of the curve.

        Args:
            df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
        &#34;length&#34;.
            length_cut (int, optional): cut to impose on the length of
        the peaks for noise suppression. Defaults to 5.
            bins (intorlist, optional): number of bins to make the are
        histogram or list of bin edges to consider on the histogram.
        Defaults to 200.

        Returns:
            itp.interp1d: 1D interpolation object of the DCR vs area
        threshold curve.
        &#34;&#34;&#34;
        area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                                 bins=bins)
        area_hist_x = area_hist[1]
        area_hist_x = (area_hist_x +
                       (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
        area_hist_y = area_hist[0]
        DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
        DCR_func = itp.interp1d(area_hist_x, DCR_values)

        return DCR_func

    @staticmethod
    def get_DCR(df: pd.DataFrame,
                length_cut_min: int,
                length_cut_max: int,
                pe_area: float,
                sensor_area: float,
                t: float) -&gt; tuple:
        &#34;&#34;&#34;Compute the dark count rate (DCR) and crosstalk probability
        (CTP) of a dataset.

        Args:
            df (pd.DataFrame): DataFrame of the dataset (single ch)
            length_cut_min (int): low length cut to apply
            length_cut_max (int): high length cut to apply
            pe_area (float): SPE area
            sensor_area (float): effective are of the sensor
            t (float): livetime of the dataset

        Returns:
            tuple: DCR value, error of DCR value, CTP value, error of
        CTP value
        &#34;&#34;&#34;
        pe_0_5 = pe_area * 0.5
        pe_1_5 = pe_area * 1.5

        DC_0_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                        (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                        (df[&#39;area&#39;] &gt; pe_0_5)])
        DC_1_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                        (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                        (df[&#39;area&#39;] &gt; pe_1_5)])

        DC_0_5_error = np.sqrt(DC_0_5)
        DC_1_5_error = np.sqrt(DC_1_5)

        DCR = DC_0_5 / sensor_area / t
        DCR_error = DC_0_5_error / sensor_area / t

        CTP = DC_1_5 / DC_0_5
        CTP_error = np.sqrt((DC_0_5_error / DC_1_5)**2 +
                            (DC_0_5 * DC_1_5_error / (DC_1_5)**2)**2)

        return DCR, DCR_error, CTP, CTP_error

    @staticmethod
    def print_DCR_CTP(DCR: float, DCR_error: float,
                      CTP: float, CTP_error: float) -&gt; None:
        &#34;&#34;&#34;Print the dark count rate (DCR) and crosstalk probability
        (CTP) values in a nice formatted and welcoming message.

        Args:
            DCR (float): DCR value
            DCR_error (float): Error on the DCR value
            CTP (float): CTP value
            CTP_error (float): Error on the CTP value
        &#34;&#34;&#34;

        print(f&#39;Your lovely DCR is: ({DCR:.2f} +- {DCR_error:.2f}) Hz/mm^2&#39;)
        print(f&#39;Your lovely CTP is: ({CTP*100:.2f} +- {CTP_error*100:.2f})%&#39;)

    def get_gain(self, spe_area: float) -&gt; float:
        &#34;&#34;&#34;Compute the gain given the value of the SPE area

        Args:
            spe_area (float): Area of the SPE peak in integrated ADC
        counts [ADC count * ns].

        Raises:
            ValueError: self.ADC_config not defined for the current dataset.
        Run dataset.define_ADC_config(...)

        Returns:
            float: the calculated gain.
        &#34;&#34;&#34;

        if not isinstance(self.ADC_config, dict):
            raise ValueError(&#39;Define ADC_config first.&#39;)

        ADC_range = self.ADC_config[&#39;ADC_range&#39;]
        ADC_impedance = self.ADC_config[&#39;ADC_impedance&#39;]
        F_amp = self.ADC_config[&#39;F_amp&#39;]
        ADC_res = self.ADC_config[&#39;ADC_res&#39;]
        q_e = self.ADC_config[&#39;q_e&#39;]

        gain = (ADC_range * spe_area * 1e-9 / ADC_impedance / F_amp /
                ADC_res / q_e)

        return gain

    def compute_properties_of_dataset(self,
                                      length_cut_min: int = 4,
                                      length_cut_max: int = 20) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Calculate the gain, DCR, CTP and BV for the dataset in a single
        line!

        Args:
            temp (float): temperature to consider in the dataset.
            module (int): module to load.
            channel (str): channel to load.
            length_cut_min (int): lower bound accepted for the length of
        peaks. Defaults to 4.
            length_cut_max (int): upper bound accepted for the length of
        peaks. Defaults to 20.

        Returns:
            pd.DataFrame: dataframe with all the computed properties with
        the columns [&#39;V&#39;,&#39;T&#39;,&#39;path&#39;,&#39;module&#39;,&#39;channel&#39;,&#39;Gain&#39;,&#39;DCR&#39;,&#39;CTP&#39;,
        &#39;DCR_error&#39;,&#39;CTP_error&#39;,&#39;BV&#39;,&#39;OV&#39;]
        &#34;&#34;&#34;

        assert isinstance(self.data, dict), (&#39;Woops, no data found! Load&#39;
                                             &#39; data into the dataset first&#39;)

        voltage_list = self.voltages

        _results_dataset = pd.DataFrame(columns=[&#39;T&#39;, &#39;V&#39;, &#39;pe_area&#39;, &#39;Gain&#39;,
                                                 &#39;res&#39;, &#39;DCR&#39;, &#39;DCR_error&#39;,
                                                 &#39;CTP&#39;, &#39;CTP_error&#39;])

        for _volt in voltage_list:
            # select voltage
            df = self.data[_volt]
            if self.plots_flag == True:
                plot_name_1pe_fit = (f&#39;{self.temp}K_{_volt}V_mod{self.module}_&#39;
                                     f&#39;ch{self.channel}&#39;)
            else:
                plot_name_1pe_fit = False

            # Get SPE value from Gaussian fit
            (A, mu, sigma), cov = self.get_1pe_value_fit(
                df, plot=plot_name_1pe_fit)

            # Calculate DCR and CTP
            DCR, DCR_error, CTP, CTP_error = self.get_DCR(
                df=df,
                length_cut_min=length_cut_min,
                length_cut_max=length_cut_max,
                pe_area=mu,
                sensor_area=self.SiPM_config[&#39;sensor_area&#39;],
                t=self.SiPM_config[&#39;livetime&#39;])

            # Calculate gain
            gain = self.get_gain(mu)

            # Merge into rolling dataframe (I know it&#39;s slow... make a PR, pls)
            _results_dataset = pd.concat((_results_dataset,
                                          pd.DataFrame({&#39;T&#39;: [self.temp],
                                                        &#39;V&#39;: [_volt],
                                                        &#39;pe_area&#39;: [mu],
                                                        &#39;Gain&#39;: [gain],
                                                        &#39;res&#39;: [mu / sigma],
                                                        &#39;DCR&#39;: [DCR],
                                                        &#39;DCR_error&#39;: [DCR_error],
                                                        &#39;CTP&#39;: [CTP],
                                                        &#39;CTP_error&#39;: [CTP_error]})
                                          ), ignore_index=True)

        # Compute BV from gain(V) curve and update df
        if self.plots_flag == True:
            plot_BV = f&#39;BV_mod{self.module}_ch{self.channel}&#39;
        else:
            plot_BV = False
        _results_dataset = compute_BV(_results_dataset, plot_BV)

        return _results_dataset</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pylars.analysis.fingerplot.fingerplot_dataset" href="fingerplot.html#pylars.analysis.fingerplot.fingerplot_dataset">fingerplot_dataset</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_1pe_rough"><code class="name flex">
<span>def <span class="ident">get_1pe_rough</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut: int, bins: int = 200) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>From an event df (1 channel), find the rough position of the
SPE from the DCR vs threshold curve and its derivative</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>length_cut</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>intorlist</code>, optional</dt>
<dd>number of bins to make the are</dd>
</dl>
<p>histogram or list of bin edges to consider on the histogram.
Defaults to 200.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_1pe_rough(cls, df: pd.DataFrame,
                  length_cut: int,
                  bins: int or list = 200) -&gt; tuple:
    &#34;&#34;&#34;From an event df (1 channel), find the rough position of the
    SPE from the DCR vs threshold curve and its derivative

    Args:
        df (_type_): _description_
        length_cut (_type_): _description_
        bins (intorlist, optional): number of bins to make the are
    histogram or list of bin edges to consider on the histogram.
    Defaults to 200.

    Returns:
        tuple: _description_
    &#34;&#34;&#34;

    (area_hist_x, DCR_values) = cls.get_DCR_above_threshold_values(
        df, length_cut, bins)
    grad = np.gradient(DCR_values)
    grad_spline = itp.UnivariateSpline(area_hist_x, grad)
    # , s = len(area_hist_x)*3)
    _x = np.linspace(area_hist_x[0], area_hist_x[-1], 500)
    _y = grad_spline(_x)
    min_idx = np.where(_y == min(_y))
    min_area_x = _x[min_idx][0]
    return area_hist_x, DCR_values, _x, _y, min_area_x</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_1pe_value_fit"><code class="name flex">
<span>def <span class="ident">get_1pe_value_fit</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut: int = 5, plot: bool = False) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Try to fit the SPE peak in the area histogram and return the
Gaussian paramenters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>length_cut</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>cut to impose on the length of</dd>
</dl>
<p>the peaks for noise suppression. Defaults to 5.
plot (boolorstr, optional): <em>description</em>. Defaults to False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_1pe_value_fit(cls,
                      df: pd.DataFrame,
                      length_cut: int = 5,
                      plot: bool or str = False) -&gt; tuple:
    &#34;&#34;&#34;Try to fit the SPE peak in the area histogram and return the
    Gaussian paramenters.

    Args:
        df (pd.DataFrame): _description_
        length_cut (int, optional): cut to impose on the length of
    the peaks for noise suppression. Defaults to 5.
        plot (boolorstr, optional): _description_. Defaults to False.

    Returns:
        tuple: _description_
    &#34;&#34;&#34;

    (area_hist_x, DCR_values, DCR_der_x_points,
     DCR_der_y_points, min_area_x) = cls.get_1pe_rough(df, length_cut)

    if plot != False:
        pylars.plotting.plotanalysis.plot_DCR_curve(
            plot, area_hist_x, DCR_values, DCR_der_x_points,
            DCR_der_y_points, min_area_x)

    area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                             bins=np.linspace(0.5 * min_area_x, 1.5 * min_area_x, 300))
    area_hist_x = area_hist[1]
    area_hist_x = (
        area_hist_x + (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
    area_hist_y = area_hist[0]

    (A, mu, sigma), cov = curve_fit(Gaussean, area_hist_x, area_hist_y,
                                    p0=(2000, min_area_x, 0.05 * min_area_x))

    if plot != False:
        pylars.plotting.plotanalysis.plot_SPE_fit(
            df, length_cut, plot, area_hist_x, min_area_x, A, mu, sigma)

    return (A, mu, sigma), cov</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_DCR"><code class="name flex">
<span>def <span class="ident">get_DCR</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut_min: int, length_cut_max: int, pe_area: float, sensor_area: float, t: float) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the dark count rate (DCR) and crosstalk probability
(CTP) of a dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>DataFrame of the dataset (single ch)</dd>
<dt><strong><code>length_cut_min</code></strong> :&ensp;<code>int</code></dt>
<dd>low length cut to apply</dd>
<dt><strong><code>length_cut_max</code></strong> :&ensp;<code>int</code></dt>
<dd>high length cut to apply</dd>
<dt><strong><code>pe_area</code></strong> :&ensp;<code>float</code></dt>
<dd>SPE area</dd>
<dt><strong><code>sensor_area</code></strong> :&ensp;<code>float</code></dt>
<dd>effective are of the sensor</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>livetime of the dataset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>DCR value, error of DCR value, CTP value, error of</dd>
</dl>
<p>CTP value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_DCR(df: pd.DataFrame,
            length_cut_min: int,
            length_cut_max: int,
            pe_area: float,
            sensor_area: float,
            t: float) -&gt; tuple:
    &#34;&#34;&#34;Compute the dark count rate (DCR) and crosstalk probability
    (CTP) of a dataset.

    Args:
        df (pd.DataFrame): DataFrame of the dataset (single ch)
        length_cut_min (int): low length cut to apply
        length_cut_max (int): high length cut to apply
        pe_area (float): SPE area
        sensor_area (float): effective are of the sensor
        t (float): livetime of the dataset

    Returns:
        tuple: DCR value, error of DCR value, CTP value, error of
    CTP value
    &#34;&#34;&#34;
    pe_0_5 = pe_area * 0.5
    pe_1_5 = pe_area * 1.5

    DC_0_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                    (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                    (df[&#39;area&#39;] &gt; pe_0_5)])
    DC_1_5 = len(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
                    (df[&#39;length&#39;] &lt; length_cut_max) &amp;
                    (df[&#39;area&#39;] &gt; pe_1_5)])

    DC_0_5_error = np.sqrt(DC_0_5)
    DC_1_5_error = np.sqrt(DC_1_5)

    DCR = DC_0_5 / sensor_area / t
    DCR_error = DC_0_5_error / sensor_area / t

    CTP = DC_1_5 / DC_0_5
    CTP_error = np.sqrt((DC_0_5_error / DC_1_5)**2 +
                        (DC_0_5 * DC_1_5_error / (DC_1_5)**2)**2)

    return DCR, DCR_error, CTP, CTP_error</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_interp1d"><code class="name flex">
<span>def <span class="ident">get_DCR_above_threshold_interp1d</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut: int = 5, bins: int = 200) ‑> scipy.interpolate.interpolate.interp1d</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the event rate in a sweep of area thresholds and
returns a 1D interpolation object of the curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>a pd.DataFrame with the series "area" and</dd>
</dl>
<p>"length".
length_cut (int, optional): cut to impose on the length of
the peaks for noise suppression. Defaults to 5.
bins (intorlist, optional): number of bins to make the are
histogram or list of bin edges to consider on the histogram.
Defaults to 200.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>itp.interp1d</code></dt>
<dd>1D interpolation object of the DCR vs area</dd>
</dl>
<p>threshold curve.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_DCR_above_threshold_interp1d(cls, df: pd.DataFrame,
                                     length_cut: int = 5,
                                     bins: int or list = 200
                                     ) -&gt; itp.interp1d:
    &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
    returns a 1D interpolation object of the curve.

    Args:
        df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
    &#34;length&#34;.
        length_cut (int, optional): cut to impose on the length of
    the peaks for noise suppression. Defaults to 5.
        bins (intorlist, optional): number of bins to make the are
    histogram or list of bin edges to consider on the histogram.
    Defaults to 200.

    Returns:
        itp.interp1d: 1D interpolation object of the DCR vs area
    threshold curve.
    &#34;&#34;&#34;
    area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                             bins=bins)
    area_hist_x = area_hist[1]
    area_hist_x = (area_hist_x +
                   (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
    area_hist_y = area_hist[0]
    DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
    DCR_func = itp.interp1d(area_hist_x, DCR_values)

    return DCR_func</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_spline"><code class="name flex">
<span>def <span class="ident">get_DCR_above_threshold_spline</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut: int = 5, bins: int = 200, **kwargs) ‑> scipy.interpolate.fitpack2.UnivariateSpline</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the event rate in a sweep of area thresholds and
returns a spline object of the curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>a pd.DataFrame with the series "area" and</dd>
</dl>
<p>"length".
length_cut (int, optional): cut to impose on the length of
the peaks for noise suppression. Defaults to 5.
bins (intorlist, optional): number of bins to make the are
histogram or list of bin edges to consider on the histogram.
Defaults to 200.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>itp.UnivariateSpline</code></dt>
<dd>spline object of the DCR vs area</dd>
</dl>
<p>threshold curve.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_DCR_above_threshold_spline(cls, df: pd.DataFrame,
                                   length_cut: int = 5,
                                   bins: int or list = 200,
                                   **kwargs) -&gt; itp.UnivariateSpline:
    &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
    returns a spline object of the curve.

    Args:
        df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
    &#34;length&#34;.
        length_cut (int, optional): cut to impose on the length of
    the peaks for noise suppression. Defaults to 5.
        bins (intorlist, optional): number of bins to make the are
    histogram or list of bin edges to consider on the histogram.
    Defaults to 200.

    Returns:
        itp.UnivariateSpline: spline object of the DCR vs area
    threshold curve.
    &#34;&#34;&#34;
    area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                             bins=bins)
    area_hist_x = area_hist[1]
    area_hist_x = (area_hist_x +
                   (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
    area_hist_y = area_hist[0]
    DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))
    DCR_func = itp.UnivariateSpline(area_hist_x, DCR_values, **kwargs)

    return DCR_func</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_values"><code class="name flex">
<span>def <span class="ident">get_DCR_above_threshold_values</span></span>(<span>df: pandas.core.frame.DataFrame, length_cut: int = 5, bins: int = 200) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the event rate in a sweep of area thresholds and
returns the pair [area thersholds, DCR values]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>a pd.DataFrame with the series "area" and</dd>
</dl>
<p>"length".
length_cut (int, optional): cut to impose on the length of
the peaks for noise suppression. Defaults to 5.
bins (intorlist, optional): number of bins to make the are
histogram or list of bin edges to consider on the histogram.
Defaults to 200.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>pair of np.arrays (area thersholds, DCR values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_DCR_above_threshold_values(cls, df: pd.DataFrame,
                                   length_cut: int = 5,
                                   bins: int or list = 200) -&gt; tuple:
    &#34;&#34;&#34;Computes the event rate in a sweep of area thresholds and
    returns the pair [area thersholds, DCR values]

    Args:
        df (pd.DataFrame): a pd.DataFrame with the series &#34;area&#34; and
    &#34;length&#34;.
        length_cut (int, optional): cut to impose on the length of
    the peaks for noise suppression. Defaults to 5.
        bins (intorlist, optional): number of bins to make the are
    histogram or list of bin edges to consider on the histogram.
    Defaults to 200.

    Returns:
        tuple: pair of np.arrays (area thersholds, DCR values)
    &#34;&#34;&#34;
    area_hist = np.histogram(df[df[&#39;length&#39;] &gt; length_cut][&#39;area&#39;],
                             bins=bins)
    area_hist_x = area_hist[1]
    area_hist_x = (area_hist_x +
                   (area_hist_x[1] - area_hist_x[0]) / 2)[:-1]
    area_hist_y = area_hist[0]

    DCR_values = np.flip(np.cumsum(np.flip(area_hist_y)))

    return (area_hist_x, DCR_values)</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.print_DCR_CTP"><code class="name flex">
<span>def <span class="ident">print_DCR_CTP</span></span>(<span>DCR: float, DCR_error: float, CTP: float, CTP_error: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Print the dark count rate (DCR) and crosstalk probability
(CTP) values in a nice formatted and welcoming message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DCR</code></strong> :&ensp;<code>float</code></dt>
<dd>DCR value</dd>
<dt><strong><code>DCR_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Error on the DCR value</dd>
<dt><strong><code>CTP</code></strong> :&ensp;<code>float</code></dt>
<dd>CTP value</dd>
<dt><strong><code>CTP_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Error on the CTP value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def print_DCR_CTP(DCR: float, DCR_error: float,
                  CTP: float, CTP_error: float) -&gt; None:
    &#34;&#34;&#34;Print the dark count rate (DCR) and crosstalk probability
    (CTP) values in a nice formatted and welcoming message.

    Args:
        DCR (float): DCR value
        DCR_error (float): Error on the DCR value
        CTP (float): CTP value
        CTP_error (float): Error on the CTP value
    &#34;&#34;&#34;

    print(f&#39;Your lovely DCR is: ({DCR:.2f} +- {DCR_error:.2f}) Hz/mm^2&#39;)
    print(f&#39;Your lovely CTP is: ({CTP*100:.2f} +- {CTP_error*100:.2f})%&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pylars.analysis.darkcount.DCR_dataset.compute_properties_of_dataset"><code class="name flex">
<span>def <span class="ident">compute_properties_of_dataset</span></span>(<span>self, length_cut_min: int = 4, length_cut_max: int = 20) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the gain, DCR, CTP and BV for the dataset in a single
line!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temp</code></strong> :&ensp;<code>float</code></dt>
<dd>temperature to consider in the dataset.</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>int</code></dt>
<dd>module to load.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>str</code></dt>
<dd>channel to load.</dd>
<dt><strong><code>length_cut_min</code></strong> :&ensp;<code>int</code></dt>
<dd>lower bound accepted for the length of</dd>
</dl>
<p>peaks. Defaults to 4.
length_cut_max (int): upper bound accepted for the length of
peaks. Defaults to 20.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>dataframe with all the computed properties with</dd>
</dl>
<p>the columns ['V','T','path','module','channel','Gain','DCR','CTP',
'DCR_error','CTP_error','BV','OV']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_properties_of_dataset(self,
                                  length_cut_min: int = 4,
                                  length_cut_max: int = 20) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Calculate the gain, DCR, CTP and BV for the dataset in a single
    line!

    Args:
        temp (float): temperature to consider in the dataset.
        module (int): module to load.
        channel (str): channel to load.
        length_cut_min (int): lower bound accepted for the length of
    peaks. Defaults to 4.
        length_cut_max (int): upper bound accepted for the length of
    peaks. Defaults to 20.

    Returns:
        pd.DataFrame: dataframe with all the computed properties with
    the columns [&#39;V&#39;,&#39;T&#39;,&#39;path&#39;,&#39;module&#39;,&#39;channel&#39;,&#39;Gain&#39;,&#39;DCR&#39;,&#39;CTP&#39;,
    &#39;DCR_error&#39;,&#39;CTP_error&#39;,&#39;BV&#39;,&#39;OV&#39;]
    &#34;&#34;&#34;

    assert isinstance(self.data, dict), (&#39;Woops, no data found! Load&#39;
                                         &#39; data into the dataset first&#39;)

    voltage_list = self.voltages

    _results_dataset = pd.DataFrame(columns=[&#39;T&#39;, &#39;V&#39;, &#39;pe_area&#39;, &#39;Gain&#39;,
                                             &#39;res&#39;, &#39;DCR&#39;, &#39;DCR_error&#39;,
                                             &#39;CTP&#39;, &#39;CTP_error&#39;])

    for _volt in voltage_list:
        # select voltage
        df = self.data[_volt]
        if self.plots_flag == True:
            plot_name_1pe_fit = (f&#39;{self.temp}K_{_volt}V_mod{self.module}_&#39;
                                 f&#39;ch{self.channel}&#39;)
        else:
            plot_name_1pe_fit = False

        # Get SPE value from Gaussian fit
        (A, mu, sigma), cov = self.get_1pe_value_fit(
            df, plot=plot_name_1pe_fit)

        # Calculate DCR and CTP
        DCR, DCR_error, CTP, CTP_error = self.get_DCR(
            df=df,
            length_cut_min=length_cut_min,
            length_cut_max=length_cut_max,
            pe_area=mu,
            sensor_area=self.SiPM_config[&#39;sensor_area&#39;],
            t=self.SiPM_config[&#39;livetime&#39;])

        # Calculate gain
        gain = self.get_gain(mu)

        # Merge into rolling dataframe (I know it&#39;s slow... make a PR, pls)
        _results_dataset = pd.concat((_results_dataset,
                                      pd.DataFrame({&#39;T&#39;: [self.temp],
                                                    &#39;V&#39;: [_volt],
                                                    &#39;pe_area&#39;: [mu],
                                                    &#39;Gain&#39;: [gain],
                                                    &#39;res&#39;: [mu / sigma],
                                                    &#39;DCR&#39;: [DCR],
                                                    &#39;DCR_error&#39;: [DCR_error],
                                                    &#39;CTP&#39;: [CTP],
                                                    &#39;CTP_error&#39;: [CTP_error]})
                                      ), ignore_index=True)

    # Compute BV from gain(V) curve and update df
    if self.plots_flag == True:
        plot_BV = f&#39;BV_mod{self.module}_ch{self.channel}&#39;
    else:
        plot_BV = False
    _results_dataset = compute_BV(_results_dataset, plot_BV)

    return _results_dataset</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.define_ADC_config"><code class="name flex">
<span>def <span class="ident">define_ADC_config</span></span>(<span>self, F_amp: float, ADC_range: int = 2.25, ADC_impedance: int = 50, ADC_res: float = 16384, q_e: float = 1.602176634e-19) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define the ADC related quantities for the dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>F_amp</code></strong> :&ensp;<code>float</code></dt>
<dd>signal amplification from the sensor (pre-amp *</dd>
</dl>
<p>external amplification on rack)
ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
ADC_impedance (int, optional): Impedance of the ADC and cables
[ohm]. Defaults to 50.
ADC_res (float, optional): Resolution/bits of the ADC (2<strong>N_bits).
Defaults to 2</strong>14.
q_e (float, optional): Element charge of the electron [C].
Defaults to 1.602176634e-19.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                      ADC_impedance: int = 50, ADC_res: float = 2**14,
                      q_e: float = 1.602176634e-19) -&gt; None:
    &#34;&#34;&#34;Define the ADC related quantities for the dataset.

    Args:
        F_amp (float): signal amplification from the sensor (pre-amp *
    external amplification on rack)
        ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
        ADC_impedance (int, optional): Impedance of the ADC and cables
    [ohm]. Defaults to 50.
        ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
    Defaults to 2**14.
        q_e (float, optional): Element charge of the electron [C].
    Defaults to 1.602176634e-19.
    &#34;&#34;&#34;
    ADC_config = {&#39;ADC_range&#39;: ADC_range,
                  &#39;ADC_impedance&#39;: ADC_impedance,
                  &#39;F_amp&#39;: F_amp,
                  &#39;ADC_res&#39;: ADC_res,
                  &#39;q_e&#39;: q_e}

    self.ADC_config = ADC_config</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.define_SiPM_config"><code class="name flex">
<span>def <span class="ident">define_SiPM_config</span></span>(<span>self, livetime: float, sensor_area: float = 144) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define the SiPM data related quantities for the dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>livetime</code></strong> :&ensp;<code>float</code></dt>
<dd>livetime of the measurement for DCR porpuses.</dd>
<dt><strong><code>sensor_area</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Area of the photosensor (mm**2).</dd>
</dl>
<p>Defaults to 12*12.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_SiPM_config(self, livetime: float,
                       sensor_area: float = 12 * 12,
                       ) -&gt; None:
    &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

    Args:
        livetime (float): livetime of the measurement for DCR porpuses.
        sensor_area (float, optional): Area of the photosensor (mm**2).
    Defaults to 12*12.
    &#34;&#34;&#34;
    SiPM_config = {&#39;livetime&#39;: livetime,
                   &#39;sensor_area&#39;: sensor_area,
                   }

    self.SiPM_config = SiPM_config</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_gain"><code class="name flex">
<span>def <span class="ident">get_gain</span></span>(<span>self, spe_area: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the gain given the value of the SPE area</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spe_area</code></strong> :&ensp;<code>float</code></dt>
<dd>Area of the SPE peak in integrated ADC</dd>
</dl>
<p>counts [ADC count * ns].</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>self.ADC_config not defined for the current dataset.</dd>
</dl>
<p>Run dataset.define_ADC_config(&hellip;)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the calculated gain.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gain(self, spe_area: float) -&gt; float:
    &#34;&#34;&#34;Compute the gain given the value of the SPE area

    Args:
        spe_area (float): Area of the SPE peak in integrated ADC
    counts [ADC count * ns].

    Raises:
        ValueError: self.ADC_config not defined for the current dataset.
    Run dataset.define_ADC_config(...)

    Returns:
        float: the calculated gain.
    &#34;&#34;&#34;

    if not isinstance(self.ADC_config, dict):
        raise ValueError(&#39;Define ADC_config first.&#39;)

    ADC_range = self.ADC_config[&#39;ADC_range&#39;]
    ADC_impedance = self.ADC_config[&#39;ADC_impedance&#39;]
    F_amp = self.ADC_config[&#39;F_amp&#39;]
    ADC_res = self.ADC_config[&#39;ADC_res&#39;]
    q_e = self.ADC_config[&#39;q_e&#39;]

    gain = (ADC_range * spe_area * 1e-9 / ADC_impedance / F_amp /
            ADC_res / q_e)

    return gain</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.get_voltages_available"><code class="name flex">
<span>def <span class="ident">get_voltages_available</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Checks the loaded run for which voltages are available for the
defined temperature.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>array of the available voltages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltages_available(self) -&gt; np.array:
    &#34;&#34;&#34;Checks the loaded run for which voltages are available for the
    defined temperature.

    Returns:
        np.array: array of the available voltages
    &#34;&#34;&#34;

    voltages = []
    for _dataset in self.run.datasets:
        if (_dataset.temp == self.temp) and (_dataset.kind == &#39;DCR&#39;):
            voltages.append(_dataset.vbias)
    voltages = np.unique(voltages)

    return voltages</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.load_processed_data"><code class="name flex">
<span>def <span class="ident">load_processed_data</span></span>(<span>self, force_processing: bool = False) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>For all the voltages of a DCR_dataset (smae temperature) looks
for already processed files to load. If force_processing=True and
no saved file is found, processes the dataset with standard
options (sigma = 5, N_baseline = 50).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force_processing</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to force processing</dd>
</dl>
<p>of raw data in case the processed dataset is not found. Defaults
to False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_processed_data(self, force_processing: bool = False) -&gt; dict:
    &#34;&#34;&#34;For all the voltages of a DCR_dataset (smae temperature) looks
    for already processed files to load. If force_processing=True and
    no saved file is found, processes the dataset with standard
    options (sigma = 5, N_baseline = 50).

    Args:
        force_processing (bool, optional): Flag to force processing
    of raw data in case the processed dataset is not found. Defaults
    to False.

    Returns:
        dict: _description_
    &#34;&#34;&#34;
    self.data = {}
    for _voltage in self.voltages:
        processed_data = pylars.utils.output.processed_dataset(
            run=self.run,
            kind=&#39;DCR&#39;,
            vbias=_voltage,
            temp=self.temp,
            path_processed=(&#39;/disk/gfs_atp/xenoscope/SiPMs/char_campaign/&#39;
                            &#39;processed_data/&#39;),
            process_hash=self.process.hash)
        processed_data.load_data(force=force_processing)

        _df = processed_data.data
        mask = ((_df[&#39;module&#39;] == self.module) &amp;
                (_df[&#39;channel&#39;] == self.channel))

        self.data[_voltage] = copy.deepcopy(_df[mask])</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_dataset.set_plots_flag"><code class="name flex">
<span>def <span class="ident">set_plots_flag</span></span>(<span>self, flag: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set if computing properties makes plots (True) or not (False).
Assumes a ./figures/ directory exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>True for plotting stuff, False for not making nice</dd>
</dl>
<p>pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
wall and it looks nice.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_plots_flag(self, flag: bool) -&gt; None:
    &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
    Assumes a ./figures/ directory exists.

    Args:
        flag (bool): True for plotting stuff, False for not making nice
    pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
    wall and it looks nice.
    &#34;&#34;&#34;
    self.plots_flag = flag</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run"><code class="flex name class">
<span>class <span class="ident">DCR_run</span></span>
<span>(</span><span>run: <a title="pylars.utils.input.run" href="../utils/input.html#pylars.utils.input.run">run</a>, processor: <a title="pylars.processing.rawprocessor.run_processor" href="../processing/rawprocessor.html#pylars.processing.rawprocessor.run_processor">run_processor</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection of all the DCR_datasets results for a run, ie, for all
the channels and modules, for every available temperatures and voltages.</p>
<p>The results of every dataset (channel, V, T) is saved on the instance
DCR_run.results_df .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DCR_run():
    &#34;&#34;&#34;Collection of all the DCR_datasets results for a run, ie, for all
    the channels and modules, for every available temperatures and voltages.

    The results of every dataset (channel, V, T) is saved on the instance
    DCR_run.results_df .
    &#34;&#34;&#34;

    __version__ = &#39;0.0.1&#39;

    def __init__(self, run: pylars.utils.input.run,
                 processor: pylars.processing.rawprocessor.run_processor):

        self.run = run
        self.process = processor
        self.datasets = self.process.datasets_df
        self.temperatures = self.get_run_temperatures()
        self.plots_flag = False
        self.analysis_path = (f&#39;{self.run.main_data_path[:-9]}analysis_data&#39;
                              f&#39;/run{self.run.run_number}/&#39;)

    def set_plots_flag(self, flag: bool) -&gt; None:
        &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
        Assumes a ./figures/ directory exists.

        Args:
            flag (bool): True for plotting stuff, False for not making nice
        pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
        wall and it looks nice.
        &#34;&#34;&#34;
        self.plots_flag = flag

    def get_run_temperatures(self) -&gt; np.array:
        &#34;&#34;&#34;Get all the temperatures available in the DCR run.

        Returns:
            np.array: array with all the available temperatures.
        &#34;&#34;&#34;
        temp_list = np.unique(self.datasets[&#39;temp&#39;])

        return temp_list

    def initialize_results_df(self) -&gt; None:
        &#34;&#34;&#34;Initialize a clean results_df instance in the object.
        &#34;&#34;&#34;

        results_df = pd.DataFrame(columns=[&#39;V&#39;, &#39;T&#39;, &#39;module&#39;, &#39;channel&#39;,
                                           &#39;Gain&#39;, &#39;DCR&#39;, &#39;CTP&#39;, &#39;DCR_error&#39;,
                                           &#39;CTP_error&#39;, &#39;BV&#39;, &#39;OV&#39;]
                                  )
        self.results_df = results_df

    def define_run_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                              ADC_impedance: int = 50, ADC_res: float = 2**14,
                              q_e: float = 1.602176634e-19) -&gt; None:
        &#34;&#34;&#34;Define the ADC related quantities for the dataset.

        Args:
            F_amp (float): signal amplification from the sensor (pre-amp *
        external amplification on rack)
            ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
            ADC_impedance (int, optional): Impedance of the ADC and cables
        [ohm]. Defaults to 50.
            ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
        Defaults to 2**14.
            q_e (float, optional): Element charge of the electron [C].
        Defaults to 1.602176634e-19.
        &#34;&#34;&#34;
        ADC_config = {&#39;ADC_range&#39;: ADC_range,
                      &#39;ADC_impedance&#39;: ADC_impedance,
                      &#39;F_amp&#39;: F_amp,
                      &#39;ADC_res&#39;: ADC_res,
                      &#39;q_e&#39;: q_e}

        self.ADC_config = ADC_config

    def define_run_SiPM_config(self, livetime: float,
                               sensor_area: float = 12 * 12,
                               ) -&gt; None:
        &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

        Args:
            livetime (float): livetime of the measurement for DCR porpuses.
            sensor_area (float, optional): Area of the photosensor (mm**2).
        Defaults to 12*12.
        &#34;&#34;&#34;
        SiPM_config = {&#39;livetime&#39;: livetime,
                       &#39;sensor_area&#39;: sensor_area,
                       }
        self.SiPM_config = SiPM_config

    def load_dataset(self, temp: float,
                     module: int,
                     channel: str) -&gt; DCR_dataset:
        &#34;&#34;&#34;Create a DCR_dataset object for a (T, mod, ch) configuration and
        load the corresponding data into it.
        ! This assumes processed data is availabel for all the raw files of
        the DCR run datasets !

        Args:
            temp (float): temperature to consider
            module (int): module to load
            channel (str): channel in the module to select

        Returns:
            DCR_dataset: _description_
        &#34;&#34;&#34;
        particular_DCR_dataset = DCR_dataset(run=self.run,
                                             temperature=temp,
                                             module=module,
                                             channel=channel,
                                             processor=self.process,
                                             )

        particular_DCR_dataset.load_processed_data()

        return particular_DCR_dataset

    def compute_properties_of_ds(self, temp: float,
                                 module: int,
                                 channel: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Loads and computes the properties of a single dataset (temp,
        module, channel) by creating a DCR_dataset object and calling its
        methods.

        Args:
            temp (float): temperature
            module (int): module
            channel (str): channel

        Returns:
            pd.DataFrame: dataframe
        &#34;&#34;&#34;

        assert isinstance(self.SiPM_config, dict), &#39;No SiPM_config found!&#39;
        assert isinstance(self.ADC_config, dict), &#39;No ADC_config found!&#39;

        ds = self.load_dataset(temp, module, channel)
        ds.set_plots_flag(self.plots_flag)
        ds.ADC_config = self.ADC_config
        ds.SiPM_config = self.SiPM_config

        ds_results = ds.compute_properties_of_dataset()

        # Add module and channel columns
        module_Series = pd.Series([module] * len(ds_results), name=&#39;module&#39;)
        channel_Series = pd.Series([channel] * len(ds_results), name=&#39;channel&#39;)
        ds_results = pd.concat([ds_results, module_Series, channel_Series],
                               axis=1)
        return ds_results

    def read_channel_map(self, path_to_map: str) -&gt; None:
        &#34;&#34;&#34;Define the active modules and channels for the run.
        UNDER CONSTRUCTION. I know it doesn&#39;t work that nicely but
        I need to have somthing that works for now, so...
        Define it with self.channel_map = dict(mod:[ch#,...],...)

        Args:
            path_to_map (str): path to csv file with the channel map
        &#34;&#34;&#34;
        if self.run.run_number == 7:
            channel_map = {0: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;],
                           1: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;], }
        else:
            channel_map = pd.read_csv(path_to_map)

        self.channel_map = channel_map

    def compute_properties_of_run(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Loads and computes the properties of ALL the datasets.

        Returns:
            pd.DataFrame: The results.
        &#34;&#34;&#34;
        self.initialize_results_df()

        for temperature in self.temperatures:
            for module in self.channel_map.keys():
                for channel in tqdm(self.channel_map[module],
                                    (f&#39;Computing properties for &#39;
                                     f&#39;T={temperature}; module &#39;
                                     f&#39;{module}: &#39;)):
                    _ds_results = self.compute_properties_of_ds(
                        temp=temperature,
                        module=module,
                        channel=channel)

                    self.results_df = pd.concat([self.results_df, _ds_results],
                                                ignore_index=True)

        datetime.now()

    def save_results(self, custom_name:str = str(int(
            datetime.timestamp(datetime.now())))) -&gt; None:
        f&#34;&#34;&#34;Save dataframe of results to a hdf5 file. Saved files go to 
        {self.analysis_path} .

        Args:
            name (str): name to give the file (without extension). Defaults to
        timestamp of 
        &#34;&#34;&#34;
        assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
            &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
        assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
            &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
            &#34;disk space&#34;)

        name = f&#39;DCR_results_{custom_name}&#39;
        self.results_df.to_hdf(self.analysis_path + name + &#39;.h5&#39;, &#39;df&#39;)
        print(&#39;Saved results to &#39;)
    
    def load_results(self, name:str) -&gt; None:
        f&#34;&#34;&#34;Load dataframe of results from a hdf5 file. Looks for files in 
        {self.analysis_path} .

        Args:
            name (str): name of the file to load (without extension)
        &#34;&#34;&#34;
        assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
            &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
        assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
            &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
            &#34;disk space&#34;)

        _df = pd.read_hdf(self.analysis_path + name + &#39;.h5&#39;)
        self.results_df = _df</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pylars.analysis.darkcount.DCR_run.compute_properties_of_ds"><code class="name flex">
<span>def <span class="ident">compute_properties_of_ds</span></span>(<span>self, temp: float, module: int, channel: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Loads and computes the properties of a single dataset (temp,
module, channel) by creating a DCR_dataset object and calling its
methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temp</code></strong> :&ensp;<code>float</code></dt>
<dd>temperature</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>int</code></dt>
<dd>module</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>str</code></dt>
<dd>channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_properties_of_ds(self, temp: float,
                             module: int,
                             channel: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Loads and computes the properties of a single dataset (temp,
    module, channel) by creating a DCR_dataset object and calling its
    methods.

    Args:
        temp (float): temperature
        module (int): module
        channel (str): channel

    Returns:
        pd.DataFrame: dataframe
    &#34;&#34;&#34;

    assert isinstance(self.SiPM_config, dict), &#39;No SiPM_config found!&#39;
    assert isinstance(self.ADC_config, dict), &#39;No ADC_config found!&#39;

    ds = self.load_dataset(temp, module, channel)
    ds.set_plots_flag(self.plots_flag)
    ds.ADC_config = self.ADC_config
    ds.SiPM_config = self.SiPM_config

    ds_results = ds.compute_properties_of_dataset()

    # Add module and channel columns
    module_Series = pd.Series([module] * len(ds_results), name=&#39;module&#39;)
    channel_Series = pd.Series([channel] * len(ds_results), name=&#39;channel&#39;)
    ds_results = pd.concat([ds_results, module_Series, channel_Series],
                           axis=1)
    return ds_results</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.compute_properties_of_run"><code class="name flex">
<span>def <span class="ident">compute_properties_of_run</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Loads and computes the properties of ALL the datasets.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_properties_of_run(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Loads and computes the properties of ALL the datasets.

    Returns:
        pd.DataFrame: The results.
    &#34;&#34;&#34;
    self.initialize_results_df()

    for temperature in self.temperatures:
        for module in self.channel_map.keys():
            for channel in tqdm(self.channel_map[module],
                                (f&#39;Computing properties for &#39;
                                 f&#39;T={temperature}; module &#39;
                                 f&#39;{module}: &#39;)):
                _ds_results = self.compute_properties_of_ds(
                    temp=temperature,
                    module=module,
                    channel=channel)

                self.results_df = pd.concat([self.results_df, _ds_results],
                                            ignore_index=True)

    datetime.now()</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.define_run_ADC_config"><code class="name flex">
<span>def <span class="ident">define_run_ADC_config</span></span>(<span>self, F_amp: float, ADC_range: int = 2.25, ADC_impedance: int = 50, ADC_res: float = 16384, q_e: float = 1.602176634e-19) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define the ADC related quantities for the dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>F_amp</code></strong> :&ensp;<code>float</code></dt>
<dd>signal amplification from the sensor (pre-amp *</dd>
</dl>
<p>external amplification on rack)
ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
ADC_impedance (int, optional): Impedance of the ADC and cables
[ohm]. Defaults to 50.
ADC_res (float, optional): Resolution/bits of the ADC (2<strong>N_bits).
Defaults to 2</strong>14.
q_e (float, optional): Element charge of the electron [C].
Defaults to 1.602176634e-19.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_run_ADC_config(self, F_amp: float, ADC_range: int = 2.25,
                          ADC_impedance: int = 50, ADC_res: float = 2**14,
                          q_e: float = 1.602176634e-19) -&gt; None:
    &#34;&#34;&#34;Define the ADC related quantities for the dataset.

    Args:
        F_amp (float): signal amplification from the sensor (pre-amp *
    external amplification on rack)
        ADC_range (int, optional): Range of the ADC [V]. Defaults to 2.25.
        ADC_impedance (int, optional): Impedance of the ADC and cables
    [ohm]. Defaults to 50.
        ADC_res (float, optional): Resolution/bits of the ADC (2**N_bits).
    Defaults to 2**14.
        q_e (float, optional): Element charge of the electron [C].
    Defaults to 1.602176634e-19.
    &#34;&#34;&#34;
    ADC_config = {&#39;ADC_range&#39;: ADC_range,
                  &#39;ADC_impedance&#39;: ADC_impedance,
                  &#39;F_amp&#39;: F_amp,
                  &#39;ADC_res&#39;: ADC_res,
                  &#39;q_e&#39;: q_e}

    self.ADC_config = ADC_config</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.define_run_SiPM_config"><code class="name flex">
<span>def <span class="ident">define_run_SiPM_config</span></span>(<span>self, livetime: float, sensor_area: float = 144) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define the SiPM data related quantities for the dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>livetime</code></strong> :&ensp;<code>float</code></dt>
<dd>livetime of the measurement for DCR porpuses.</dd>
<dt><strong><code>sensor_area</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Area of the photosensor (mm**2).</dd>
</dl>
<p>Defaults to 12*12.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_run_SiPM_config(self, livetime: float,
                           sensor_area: float = 12 * 12,
                           ) -&gt; None:
    &#34;&#34;&#34;Define the SiPM data related quantities for the dataset.

    Args:
        livetime (float): livetime of the measurement for DCR porpuses.
        sensor_area (float, optional): Area of the photosensor (mm**2).
    Defaults to 12*12.
    &#34;&#34;&#34;
    SiPM_config = {&#39;livetime&#39;: livetime,
                   &#39;sensor_area&#39;: sensor_area,
                   }
    self.SiPM_config = SiPM_config</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.get_run_temperatures"><code class="name flex">
<span>def <span class="ident">get_run_temperatures</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Get all the temperatures available in the DCR run.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>array with all the available temperatures.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_run_temperatures(self) -&gt; np.array:
    &#34;&#34;&#34;Get all the temperatures available in the DCR run.

    Returns:
        np.array: array with all the available temperatures.
    &#34;&#34;&#34;
    temp_list = np.unique(self.datasets[&#39;temp&#39;])

    return temp_list</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.initialize_results_df"><code class="name flex">
<span>def <span class="ident">initialize_results_df</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a clean results_df instance in the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_results_df(self) -&gt; None:
    &#34;&#34;&#34;Initialize a clean results_df instance in the object.
    &#34;&#34;&#34;

    results_df = pd.DataFrame(columns=[&#39;V&#39;, &#39;T&#39;, &#39;module&#39;, &#39;channel&#39;,
                                       &#39;Gain&#39;, &#39;DCR&#39;, &#39;CTP&#39;, &#39;DCR_error&#39;,
                                       &#39;CTP_error&#39;, &#39;BV&#39;, &#39;OV&#39;]
                              )
    self.results_df = results_df</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.load_dataset"><code class="name flex">
<span>def <span class="ident">load_dataset</span></span>(<span>self, temp: float, module: int, channel: str) ‑> <a title="pylars.analysis.darkcount.DCR_dataset" href="#pylars.analysis.darkcount.DCR_dataset">DCR_dataset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a DCR_dataset object for a (T, mod, ch) configuration and
load the corresponding data into it.
! This assumes processed data is availabel for all the raw files of
the DCR run datasets !</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temp</code></strong> :&ensp;<code>float</code></dt>
<dd>temperature to consider</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>int</code></dt>
<dd>module to load</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>str</code></dt>
<dd>channel in the module to select</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pylars.analysis.darkcount.DCR_dataset" href="#pylars.analysis.darkcount.DCR_dataset">DCR_dataset</a></code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dataset(self, temp: float,
                 module: int,
                 channel: str) -&gt; DCR_dataset:
    &#34;&#34;&#34;Create a DCR_dataset object for a (T, mod, ch) configuration and
    load the corresponding data into it.
    ! This assumes processed data is availabel for all the raw files of
    the DCR run datasets !

    Args:
        temp (float): temperature to consider
        module (int): module to load
        channel (str): channel in the module to select

    Returns:
        DCR_dataset: _description_
    &#34;&#34;&#34;
    particular_DCR_dataset = DCR_dataset(run=self.run,
                                         temperature=temp,
                                         module=module,
                                         channel=channel,
                                         processor=self.process,
                                         )

    particular_DCR_dataset.load_processed_data()

    return particular_DCR_dataset</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.load_results"><code class="name flex">
<span>def <span class="ident">load_results</span></span>(<span>self, name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_results(self, name:str) -&gt; None:
    f&#34;&#34;&#34;Load dataframe of results from a hdf5 file. Looks for files in 
    {self.analysis_path} .

    Args:
        name (str): name of the file to load (without extension)
    &#34;&#34;&#34;
    assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
        &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
    assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
        &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
        &#34;disk space&#34;)

    _df = pd.read_hdf(self.analysis_path + name + &#39;.h5&#39;)
    self.results_df = _df</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.read_channel_map"><code class="name flex">
<span>def <span class="ident">read_channel_map</span></span>(<span>self, path_to_map: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define the active modules and channels for the run.
UNDER CONSTRUCTION. I know it doesn't work that nicely but
I need to have somthing that works for now, so&hellip;
Define it with self.channel_map = dict(mod:[ch#,&hellip;],&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_to_map</code></strong> :&ensp;<code>str</code></dt>
<dd>path to csv file with the channel map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_channel_map(self, path_to_map: str) -&gt; None:
    &#34;&#34;&#34;Define the active modules and channels for the run.
    UNDER CONSTRUCTION. I know it doesn&#39;t work that nicely but
    I need to have somthing that works for now, so...
    Define it with self.channel_map = dict(mod:[ch#,...],...)

    Args:
        path_to_map (str): path to csv file with the channel map
    &#34;&#34;&#34;
    if self.run.run_number == 7:
        channel_map = {0: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;],
                       1: [&#39;wf0&#39;, &#39;wf3&#39;, &#39;wf4&#39;, &#39;wf6&#39;], }
    else:
        channel_map = pd.read_csv(path_to_map)

    self.channel_map = channel_map</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.save_results"><code class="name flex">
<span>def <span class="ident">save_results</span></span>(<span>self, custom_name: str = '1665054893') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_results(self, custom_name:str = str(int(
        datetime.timestamp(datetime.now())))) -&gt; None:
    f&#34;&#34;&#34;Save dataframe of results to a hdf5 file. Saved files go to 
    {self.analysis_path} .

    Args:
        name (str): name to give the file (without extension). Defaults to
    timestamp of 
    &#34;&#34;&#34;
    assert isinstance(self.results_df, pd.DataFrame), (&#34;Trying to save &#34;
        &#34;results that do not exist in the object, c&#39;mon, you know better.&#34;)
    assert len(self.results_df) &gt; 0, (&#34;Results df is empty, please compute&#34;
        &#34;something before trying to save, otherwire it&#39;s just a waste of &#34;
        &#34;disk space&#34;)

    name = f&#39;DCR_results_{custom_name}&#39;
    self.results_df.to_hdf(self.analysis_path + name + &#39;.h5&#39;, &#39;df&#39;)
    print(&#39;Saved results to &#39;)</code></pre>
</details>
</dd>
<dt id="pylars.analysis.darkcount.DCR_run.set_plots_flag"><code class="name flex">
<span>def <span class="ident">set_plots_flag</span></span>(<span>self, flag: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set if computing properties makes plots (True) or not (False).
Assumes a ./figures/ directory exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>True for plotting stuff, False for not making nice</dd>
</dl>
<p>pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
wall and it looks nice.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_plots_flag(self, flag: bool) -&gt; None:
    &#34;&#34;&#34;Set if computing properties makes plots (True) or not (False).
    Assumes a ./figures/ directory exists.

    Args:
        flag (bool): True for plotting stuff, False for not making nice
    pictures (plots) to hang on the wall. Yes, I hang plots on my bedroom
    wall and it looks nice.
    &#34;&#34;&#34;
    self.plots_flag = flag</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pylars.analysis" href="index.html">pylars.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pylars.analysis.darkcount.DCR_dataset" href="#pylars.analysis.darkcount.DCR_dataset">DCR_dataset</a></code></h4>
<ul class="">
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.compute_properties_of_dataset" href="#pylars.analysis.darkcount.DCR_dataset.compute_properties_of_dataset">compute_properties_of_dataset</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.define_ADC_config" href="#pylars.analysis.darkcount.DCR_dataset.define_ADC_config">define_ADC_config</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.define_SiPM_config" href="#pylars.analysis.darkcount.DCR_dataset.define_SiPM_config">define_SiPM_config</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_1pe_rough" href="#pylars.analysis.darkcount.DCR_dataset.get_1pe_rough">get_1pe_rough</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_1pe_value_fit" href="#pylars.analysis.darkcount.DCR_dataset.get_1pe_value_fit">get_1pe_value_fit</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_DCR" href="#pylars.analysis.darkcount.DCR_dataset.get_DCR">get_DCR</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_interp1d" href="#pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_interp1d">get_DCR_above_threshold_interp1d</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_spline" href="#pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_spline">get_DCR_above_threshold_spline</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_values" href="#pylars.analysis.darkcount.DCR_dataset.get_DCR_above_threshold_values">get_DCR_above_threshold_values</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_gain" href="#pylars.analysis.darkcount.DCR_dataset.get_gain">get_gain</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.get_voltages_available" href="#pylars.analysis.darkcount.DCR_dataset.get_voltages_available">get_voltages_available</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.load_processed_data" href="#pylars.analysis.darkcount.DCR_dataset.load_processed_data">load_processed_data</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.print_DCR_CTP" href="#pylars.analysis.darkcount.DCR_dataset.print_DCR_CTP">print_DCR_CTP</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_dataset.set_plots_flag" href="#pylars.analysis.darkcount.DCR_dataset.set_plots_flag">set_plots_flag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pylars.analysis.darkcount.DCR_run" href="#pylars.analysis.darkcount.DCR_run">DCR_run</a></code></h4>
<ul class="">
<li><code><a title="pylars.analysis.darkcount.DCR_run.compute_properties_of_ds" href="#pylars.analysis.darkcount.DCR_run.compute_properties_of_ds">compute_properties_of_ds</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.compute_properties_of_run" href="#pylars.analysis.darkcount.DCR_run.compute_properties_of_run">compute_properties_of_run</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.define_run_ADC_config" href="#pylars.analysis.darkcount.DCR_run.define_run_ADC_config">define_run_ADC_config</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.define_run_SiPM_config" href="#pylars.analysis.darkcount.DCR_run.define_run_SiPM_config">define_run_SiPM_config</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.get_run_temperatures" href="#pylars.analysis.darkcount.DCR_run.get_run_temperatures">get_run_temperatures</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.initialize_results_df" href="#pylars.analysis.darkcount.DCR_run.initialize_results_df">initialize_results_df</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.load_dataset" href="#pylars.analysis.darkcount.DCR_run.load_dataset">load_dataset</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.load_results" href="#pylars.analysis.darkcount.DCR_run.load_results">load_results</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.read_channel_map" href="#pylars.analysis.darkcount.DCR_run.read_channel_map">read_channel_map</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.save_results" href="#pylars.analysis.darkcount.DCR_run.save_results">save_results</a></code></li>
<li><code><a title="pylars.analysis.darkcount.DCR_run.set_plots_flag" href="#pylars.analysis.darkcount.DCR_run.set_plots_flag">set_plots_flag</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>