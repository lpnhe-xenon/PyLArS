<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pylars.processing.peaks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pylars.processing.peaks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import numba as nb

class peak_processing():
    &#34;&#34;&#34;All the things peaks. Peaks are sums of pulses found in waveforms.

    This class, by definition, is a collection of class methods related 
    to peak processing to be used in `peakprocessor`, where a processor 
    object is then constructed.
    &#34;&#34;&#34;       

    @classmethod
    def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.array, 
                             ADC_config: dict) -&gt; np.array:
        &#34;&#34;&#34;Convert ADC counts/sample to charge.

        Applies the charge converting factor to waveforms to turn ADC counts 
        (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
        can be one or more channels.

        Args:
            waveforms_subtracted (np.array): value of ADC counts per sample 
                above calculate local baseline
            ADC_config (dict): dictionary with the ADC config

        Raises:
            ValueError: If the parsed ADC_config dictionary does not have the 
                required keys.

        Returns:
            np.array: waveforms in charge.
        &#34;&#34;&#34;

        try:
            ADC_range = ADC_config[&#39;ADC_range&#39;]
            ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
            F_amp = ADC_config[&#39;F_amp&#39;]
            ADC_res = ADC_config[&#39;ADC_res&#39;]
            q_e = ADC_config[&#39;q_e&#39;]
            dt = ADC_config[&#39;dt&#39;]
        except:
            raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                             &#39;something.&#39;)
        
        to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                         ADC_res / q_e)

        waveforms_charge = waveforms_subtracted * to_e_constant

        return waveforms_charge

    @classmethod
    def apply_e_to_pe(self,waveforms_charge: np.array,
                      gains: np.array) -&gt; np.array:
        &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

        Takes waveforms already converted to charge from ADC counts and an 
        array with the gains for each channel in units of [e/pe]. The ammount 
        of rows in the waveform array needs to be the same as the length of 
        the gains array.

        The gains array is assumed to be on the correct order in respect to 
        the order of channels in waveforms_charge.

        Args:
            waveforms_charge (_type_): _description_

        Returns:
            np.array: 
        &#34;&#34;&#34;

        assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
        gains and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_pe = (waveforms_charge.T / gains).T

        return waveforms_pe

    @classmethod
    def apply_baseline_subtract(cls, waveforms: np.array, 
                                baselines:np.array) -&gt; np.array:
        &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
        pulses.

        Args:
             waveforms (np.array): waveforms, all channels stacked by rows.
            baselines (np.array): computed baselines, all channels stacked 
                by rows.

        Returns:
            np.array: waveforms flipped and where 0 is local baseline.
        &#34;&#34;&#34;

        assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
        baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_subtracted = (baselines - waveforms.T).T

        return waveforms_subtracted

    @classmethod
    def apply_waveforms_transform(cls, waveforms: np.array,
                                  baselines: np.array,
                                  gains: np.array,
                                  ADC_config: dict) -&gt; np.array:
        &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
        
        Takes the initials waveforms stacked for all channels and returns 
        the waveforms in converted pe/s space.

        Args:
            waveforms (np.array): waveforms, all channels stacked by rows.
            baselines (np.array): computed baselines, all channels stacked 
                by rows.
            gains (np.array): gains, all channels stacked by rows.
            ADC_config (dict): dictionary with the specific digitizer configs.

        Returns:
            np.array: transformed waveforms
        &#34;&#34;&#34;

        waveforms_subtracted = cls.apply_baseline_subtract(
            waveforms, baselines)
        waveforms_charge = cls.apply_ADCcounts_to_e(
            waveforms_subtracted, ADC_config)
        waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

        return waveforms_pe

    @classmethod
    def get_sum_waveform(cls, waveforms_pe: np.array) -&gt; np.array:
        &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

        Args:
            waveforms_pe (np.array): array with waveforms from all the 
                channels.

        Returns:
            np.array: Summed waveform.
        &#34;&#34;&#34;

        summed_waveform = np.sum(waveforms_pe, axis = 0)

        return summed_waveform</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pylars.processing.peaks.peak_processing"><code class="flex name class">
<span>class <span class="ident">peak_processing</span></span>
</code></dt>
<dd>
<div class="desc"><p>All the things peaks. Peaks are sums of pulses found in waveforms.</p>
<p>This class, by definition, is a collection of class methods related
to peak processing to be used in <code>peakprocessor</code>, where a processor
object is then constructed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class peak_processing():
    &#34;&#34;&#34;All the things peaks. Peaks are sums of pulses found in waveforms.

    This class, by definition, is a collection of class methods related 
    to peak processing to be used in `peakprocessor`, where a processor 
    object is then constructed.
    &#34;&#34;&#34;       

    @classmethod
    def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.array, 
                             ADC_config: dict) -&gt; np.array:
        &#34;&#34;&#34;Convert ADC counts/sample to charge.

        Applies the charge converting factor to waveforms to turn ADC counts 
        (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
        can be one or more channels.

        Args:
            waveforms_subtracted (np.array): value of ADC counts per sample 
                above calculate local baseline
            ADC_config (dict): dictionary with the ADC config

        Raises:
            ValueError: If the parsed ADC_config dictionary does not have the 
                required keys.

        Returns:
            np.array: waveforms in charge.
        &#34;&#34;&#34;

        try:
            ADC_range = ADC_config[&#39;ADC_range&#39;]
            ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
            F_amp = ADC_config[&#39;F_amp&#39;]
            ADC_res = ADC_config[&#39;ADC_res&#39;]
            q_e = ADC_config[&#39;q_e&#39;]
            dt = ADC_config[&#39;dt&#39;]
        except:
            raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                             &#39;something.&#39;)
        
        to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                         ADC_res / q_e)

        waveforms_charge = waveforms_subtracted * to_e_constant

        return waveforms_charge

    @classmethod
    def apply_e_to_pe(self,waveforms_charge: np.array,
                      gains: np.array) -&gt; np.array:
        &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

        Takes waveforms already converted to charge from ADC counts and an 
        array with the gains for each channel in units of [e/pe]. The ammount 
        of rows in the waveform array needs to be the same as the length of 
        the gains array.

        The gains array is assumed to be on the correct order in respect to 
        the order of channels in waveforms_charge.

        Args:
            waveforms_charge (_type_): _description_

        Returns:
            np.array: 
        &#34;&#34;&#34;

        assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
        gains and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_pe = (waveforms_charge.T / gains).T

        return waveforms_pe

    @classmethod
    def apply_baseline_subtract(cls, waveforms: np.array, 
                                baselines:np.array) -&gt; np.array:
        &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
        pulses.

        Args:
             waveforms (np.array): waveforms, all channels stacked by rows.
            baselines (np.array): computed baselines, all channels stacked 
                by rows.

        Returns:
            np.array: waveforms flipped and where 0 is local baseline.
        &#34;&#34;&#34;

        assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
        baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_subtracted = (baselines - waveforms.T).T

        return waveforms_subtracted

    @classmethod
    def apply_waveforms_transform(cls, waveforms: np.array,
                                  baselines: np.array,
                                  gains: np.array,
                                  ADC_config: dict) -&gt; np.array:
        &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
        
        Takes the initials waveforms stacked for all channels and returns 
        the waveforms in converted pe/s space.

        Args:
            waveforms (np.array): waveforms, all channels stacked by rows.
            baselines (np.array): computed baselines, all channels stacked 
                by rows.
            gains (np.array): gains, all channels stacked by rows.
            ADC_config (dict): dictionary with the specific digitizer configs.

        Returns:
            np.array: transformed waveforms
        &#34;&#34;&#34;

        waveforms_subtracted = cls.apply_baseline_subtract(
            waveforms, baselines)
        waveforms_charge = cls.apply_ADCcounts_to_e(
            waveforms_subtracted, ADC_config)
        waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

        return waveforms_pe

    @classmethod
    def get_sum_waveform(cls, waveforms_pe: np.array) -&gt; np.array:
        &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

        Args:
            waveforms_pe (np.array): array with waveforms from all the 
                channels.

        Returns:
            np.array: Summed waveform.
        &#34;&#34;&#34;

        summed_waveform = np.sum(waveforms_pe, axis = 0)

        return summed_waveform</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e"><code class="name flex">
<span>def <span class="ident">apply_ADCcounts_to_e</span></span>(<span>waveforms_subtracted: <built-in function array>, ADC_config: dict) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Convert ADC counts/sample to charge.</p>
<p>Applies the charge converting factor to waveforms to turn ADC counts
(which are integrated over 1 sample) to charge. <code>waveforms_subtracted</code>
can be one or more channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_subtracted</code></strong> :&ensp;<code>np.array</code></dt>
<dd>value of ADC counts per sample
above calculate local baseline</dd>
<dt><strong><code>ADC_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with the ADC config</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the parsed ADC_config dictionary does not have the
required keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>waveforms in charge.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.array, 
                         ADC_config: dict) -&gt; np.array:
    &#34;&#34;&#34;Convert ADC counts/sample to charge.

    Applies the charge converting factor to waveforms to turn ADC counts 
    (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
    can be one or more channels.

    Args:
        waveforms_subtracted (np.array): value of ADC counts per sample 
            above calculate local baseline
        ADC_config (dict): dictionary with the ADC config

    Raises:
        ValueError: If the parsed ADC_config dictionary does not have the 
            required keys.

    Returns:
        np.array: waveforms in charge.
    &#34;&#34;&#34;

    try:
        ADC_range = ADC_config[&#39;ADC_range&#39;]
        ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
        F_amp = ADC_config[&#39;F_amp&#39;]
        ADC_res = ADC_config[&#39;ADC_res&#39;]
        q_e = ADC_config[&#39;q_e&#39;]
        dt = ADC_config[&#39;dt&#39;]
    except:
        raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                         &#39;something.&#39;)
    
    to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                     ADC_res / q_e)

    waveforms_charge = waveforms_subtracted * to_e_constant

    return waveforms_charge</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_baseline_subtract"><code class="name flex">
<span>def <span class="ident">apply_baseline_subtract</span></span>(<span>waveforms: <built-in function array>, baselines: <built-in function array>) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Apply baseline subtracting and flipping from negative to positive
pulses.</p>
<h2 id="args">Args</h2>
<dl>
<dt>waveforms (np.array): waveforms, all channels stacked by rows.</dt>
<dt><strong><code>baselines</code></strong> :&ensp;<code>np.array</code></dt>
<dd>computed baselines, all channels stacked
by rows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>waveforms flipped and where 0 is local baseline.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_baseline_subtract(cls, waveforms: np.array, 
                            baselines:np.array) -&gt; np.array:
    &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
    pulses.

    Args:
         waveforms (np.array): waveforms, all channels stacked by rows.
        baselines (np.array): computed baselines, all channels stacked 
            by rows.

    Returns:
        np.array: waveforms flipped and where 0 is local baseline.
    &#34;&#34;&#34;

    assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
    baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

    waveforms_subtracted = (baselines - waveforms.T).T

    return waveforms_subtracted</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_e_to_pe"><code class="name flex">
<span>def <span class="ident">apply_e_to_pe</span></span>(<span>waveforms_charge: <built-in function array>, gains: <built-in function array>) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Transform waveforms from charge to pe with gain per channel.</p>
<p>Takes waveforms already converted to charge from ADC counts and an
array with the gains for each channel in units of [e/pe]. The ammount
of rows in the waveform array needs to be the same as the length of
the gains array.</p>
<p>The gains array is assumed to be on the correct order in respect to
the order of channels in waveforms_charge.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_charge</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.array:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_e_to_pe(self,waveforms_charge: np.array,
                  gains: np.array) -&gt; np.array:
    &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

    Takes waveforms already converted to charge from ADC counts and an 
    array with the gains for each channel in units of [e/pe]. The ammount 
    of rows in the waveform array needs to be the same as the length of 
    the gains array.

    The gains array is assumed to be on the correct order in respect to 
    the order of channels in waveforms_charge.

    Args:
        waveforms_charge (_type_): _description_

    Returns:
        np.array: 
    &#34;&#34;&#34;

    assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
    gains and channels in waveforms array do not match.&#39;&#39;&#39;)

    waveforms_pe = (waveforms_charge.T / gains).T

    return waveforms_pe</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_waveforms_transform"><code class="name flex">
<span>def <span class="ident">apply_waveforms_transform</span></span>(<span>waveforms: <built-in function array>, baselines: <built-in function array>, gains: <built-in function array>, ADC_config: dict) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Converts waveforms from ADC counts/sample to pe/s.</p>
<p>Takes the initials waveforms stacked for all channels and returns
the waveforms in converted pe/s space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms</code></strong> :&ensp;<code>np.array</code></dt>
<dd>waveforms, all channels stacked by rows.</dd>
<dt><strong><code>baselines</code></strong> :&ensp;<code>np.array</code></dt>
<dd>computed baselines, all channels stacked
by rows.</dd>
<dt><strong><code>gains</code></strong> :&ensp;<code>np.array</code></dt>
<dd>gains, all channels stacked by rows.</dd>
<dt><strong><code>ADC_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with the specific digitizer configs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>transformed waveforms</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_waveforms_transform(cls, waveforms: np.array,
                              baselines: np.array,
                              gains: np.array,
                              ADC_config: dict) -&gt; np.array:
    &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
    
    Takes the initials waveforms stacked for all channels and returns 
    the waveforms in converted pe/s space.

    Args:
        waveforms (np.array): waveforms, all channels stacked by rows.
        baselines (np.array): computed baselines, all channels stacked 
            by rows.
        gains (np.array): gains, all channels stacked by rows.
        ADC_config (dict): dictionary with the specific digitizer configs.

    Returns:
        np.array: transformed waveforms
    &#34;&#34;&#34;

    waveforms_subtracted = cls.apply_baseline_subtract(
        waveforms, baselines)
    waveforms_charge = cls.apply_ADCcounts_to_e(
        waveforms_subtracted, ADC_config)
    waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

    return waveforms_pe</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.get_sum_waveform"><code class="name flex">
<span>def <span class="ident">get_sum_waveform</span></span>(<span>waveforms_pe: <built-in function array>) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Sums the (transformed to pe/s) waveforms of all channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_pe</code></strong> :&ensp;<code>np.array</code></dt>
<dd>array with waveforms from all the
channels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>Summed waveform.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_sum_waveform(cls, waveforms_pe: np.array) -&gt; np.array:
    &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

    Args:
        waveforms_pe (np.array): array with waveforms from all the 
            channels.

    Returns:
        np.array: Summed waveform.
    &#34;&#34;&#34;

    summed_waveform = np.sum(waveforms_pe, axis = 0)

    return summed_waveform</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pylars.processing" href="index.html">pylars.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pylars.processing.peaks.peak_processing" href="#pylars.processing.peaks.peak_processing">peak_processing</a></code></h4>
<ul class="">
<li><code><a title="pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e" href="#pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e">apply_ADCcounts_to_e</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_baseline_subtract" href="#pylars.processing.peaks.peak_processing.apply_baseline_subtract">apply_baseline_subtract</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_e_to_pe" href="#pylars.processing.peaks.peak_processing.apply_e_to_pe">apply_e_to_pe</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_waveforms_transform" href="#pylars.processing.peaks.peak_processing.apply_waveforms_transform">apply_waveforms_transform</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.get_sum_waveform" href="#pylars.processing.peaks.peak_processing.get_sum_waveform">get_sum_waveform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>